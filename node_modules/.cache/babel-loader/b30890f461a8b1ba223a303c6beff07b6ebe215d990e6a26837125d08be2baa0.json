{"ast":null,"code":"import * as THREE from \"three\";\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 2e-3;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 3e-3;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */new THREE.Vector3(0, 1, 0);\nconst ZAXIS = /* @__PURE__ */new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    this._onConnected = this._onConnected.bind(this);\n    this._onDisconnected = this._onDisconnected.bind(this);\n    this.hand.addEventListener(\"connected\", this._onConnected);\n    this.hand.addEventListener(\"disconnected\", this._onDisconnected);\n  }\n  _onConnected(event) {\n    const xrInputSource = event.data;\n    if (xrInputSource.hand) {\n      this.visible = true;\n      this.xrInputSource = xrInputSource;\n      this.createPointer();\n    }\n  }\n  _onDisconnected() {\n    this.visible = false;\n    this.xrInputSource = null;\n    this.pointerGeometry.dispose();\n    this.pointerMesh.material.dispose();\n    this.clear();\n  }\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array;\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n    this._drawVerticesRing(vertices, frontFaceBase, 0);\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n  }\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n    this._updatePointerVertices(POINTER_REAR_RADIUS);\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster();\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints[\"index-finger-tip\"];\n    const thumbTip = this.hand.joints[\"thumb-tip\"];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n      this._updatePointerVertices(rearRadius);\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.pointerGeometry) {\n      this._updatePointer();\n      this._updateRaycaster();\n    }\n  }\n  isPinched() {\n    return this.pinched;\n  }\n  setAttached(attached) {\n    this.attached = attached;\n  }\n  isAttached() {\n    return this.attached;\n  }\n  intersectObject(object) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n  intersectObjects(objects) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n  checkIntersections(objects) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n  dispose() {\n    this._onDisconnected();\n    this.hand.removeEventListener(\"connected\", this._onConnected);\n    this.hand.removeEventListener(\"disconnected\", this._onDisconnected);\n  }\n}\nexport { OculusHandPointerModel };","map":{"version":3,"names":["THREE","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","Object3D","constructor","hand","controller","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","_onConnected","bind","_onDisconnected","addEventListener","event","xrInputSource","data","visible","createPointer","dispose","material","clear","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","push","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","isPinched","setAttached","isAttached","intersectObject","object","recursive","arguments","length","undefined","intersectObjects","objects","checkIntersections","intersections","intersection","setCursor","removeEventListener"],"sources":["/Users/lipeichen/Desktop/CRA/laptop-3-fiber/node_modules/three-stdlib/webxr/OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from \"three\";\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 2e-3;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 3e-3;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = /* @__PURE__ */ new THREE.Vector3(0, 1, 0);\nconst ZAXIS = /* @__PURE__ */ new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    this._onConnected = this._onConnected.bind(this);\n    this._onDisconnected = this._onDisconnected.bind(this);\n    this.hand.addEventListener(\"connected\", this._onConnected);\n    this.hand.addEventListener(\"disconnected\", this._onDisconnected);\n  }\n  _onConnected(event) {\n    const xrInputSource = event.data;\n    if (xrInputSource.hand) {\n      this.visible = true;\n      this.xrInputSource = xrInputSource;\n      this.createPointer();\n    }\n  }\n  _onDisconnected() {\n    this.visible = false;\n    this.xrInputSource = null;\n    this.pointerGeometry.dispose();\n    this.pointerMesh.material.dispose();\n    this.clear();\n  }\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array;\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n    this._drawVerticesRing(vertices, frontFaceBase, 0);\n    const rearBase = new THREE.Vector3(\n      Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius,\n      Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius,\n      0\n    );\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n  }\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n    this._updatePointerVertices(POINTER_REAR_RADIUS);\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    }\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster();\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints[\"index-finger-tip\"];\n    const thumbTip = this.hand.joints[\"thumb-tip\"];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n      this._updatePointerVertices(rearRadius);\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.pointerGeometry) {\n      this._updatePointer();\n      this._updateRaycaster();\n    }\n  }\n  isPinched() {\n    return this.pinched;\n  }\n  setAttached(attached) {\n    this.attached = attached;\n  }\n  isAttached() {\n    return this.attached;\n  }\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n  dispose() {\n    this._onDisconnected();\n    this.hand.removeEventListener(\"connected\", this._onConnected);\n    this.hand.removeEventListener(\"disconnected\", this._onDisconnected);\n  }\n}\nexport {\n  OculusHandPointerModel\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}