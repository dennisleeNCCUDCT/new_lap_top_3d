{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { forwardRef, useRef, useState, useCallback, useMemo, useImperativeHandle, useEffect, Suspense, useContext, createContext } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { easing } from 'maath';\nimport { suspend, clear } from 'suspend-react';\nimport { useVideoTexture } from './useVideoTexture.js';\nimport { Facemesh } from './Facemesh.js';\nimport { useFaceLandmarker } from './FaceLandmarker.js';\n\n// useVideoTexture 1st arg `src` type\nfunction mean(v1, v2) {\n  return v1.clone().add(v2).multiplyScalar(0.5);\n}\nfunction localToLocal(objSrc, v, objDst) {\n  // see: https://discourse.threejs.org/t/object3d-localtolocal/51564\n  const v_world = objSrc.localToWorld(v);\n  return objDst.worldToLocal(v_world);\n} //\n//\n//\n\nconst FaceControlsContext = /*#__PURE__*/createContext({});\nconst FaceControls = /*#__PURE__*/forwardRef((_ref, fref) => {\n  let {\n    camera,\n    autostart = true,\n    webcam = true,\n    webcamVideoTextureSrc,\n    manualUpdate = false,\n    manualDetect = false,\n    onVideoFrame,\n    smoothTime = 0.25,\n    offset = true,\n    offsetScalar = 80,\n    eyes = false,\n    eyesAsOrigin = true,\n    depth = 0.15,\n    debug = false,\n    facemesh,\n    makeDefault\n  } = _ref;\n  var _faces$facialTransfor, _faces$faceBlendshape;\n  const scene = useThree(state => state.scene);\n  const defaultCamera = useThree(state => state.camera);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const explCamera = camera || defaultCamera;\n  const webcamApiRef = useRef(null);\n  const facemeshApiRef = useRef(null); //\n  // computeTarget()\n  //\n  // Compute `target` position and rotation for the camera (according to <Facemesh>)\n  //\n  //  1. ðŸ‘€ either following the 2 eyes\n  //  2. ðŸ‘¤ or just the head mesh\n  //\n\n  const [target] = useState(() => new THREE.Object3D());\n  const [irisRightDirPos] = useState(() => new THREE.Vector3());\n  const [irisLeftDirPos] = useState(() => new THREE.Vector3());\n  const [irisRightLookAt] = useState(() => new THREE.Vector3());\n  const [irisLeftLookAt] = useState(() => new THREE.Vector3());\n  const computeTarget = useCallback(() => {\n    // same parent as the camera\n    target.parent = explCamera.parent;\n    const facemeshApi = facemeshApiRef.current;\n    if (facemeshApi) {\n      const {\n        outerRef,\n        eyeRightRef,\n        eyeLeftRef\n      } = facemeshApi;\n      if (eyeRightRef.current && eyeLeftRef.current) {\n        // 1. ðŸ‘€\n        const {\n          irisDirRef: irisRightDirRef\n        } = eyeRightRef.current;\n        const {\n          irisDirRef: irisLeftDirRef\n        } = eyeLeftRef.current;\n        if (irisRightDirRef.current && irisLeftDirRef.current && outerRef.current) {\n          //\n          // position: mean of irisRightDirPos,irisLeftDirPos\n          //\n          irisRightDirPos.copy(localToLocal(irisRightDirRef.current, new THREE.Vector3(0, 0, 0), outerRef.current));\n          irisLeftDirPos.copy(localToLocal(irisLeftDirRef.current, new THREE.Vector3(0, 0, 0), outerRef.current));\n          target.position.copy(localToLocal(outerRef.current, mean(irisRightDirPos, irisLeftDirPos), explCamera.parent || scene)); //\n          // lookAt: mean of irisRightLookAt,irisLeftLookAt\n          //\n\n          irisRightLookAt.copy(localToLocal(irisRightDirRef.current, new THREE.Vector3(0, 0, 1), outerRef.current));\n          irisLeftLookAt.copy(localToLocal(irisLeftDirRef.current, new THREE.Vector3(0, 0, 1), outerRef.current));\n          target.lookAt(outerRef.current.localToWorld(mean(irisRightLookAt, irisLeftLookAt)));\n        }\n      } else {\n        // 2. ðŸ‘¤\n        if (outerRef.current) {\n          target.position.copy(localToLocal(outerRef.current, new THREE.Vector3(0, 0, 0), explCamera.parent || scene));\n          target.lookAt(outerRef.current.localToWorld(new THREE.Vector3(0, 0, 1)));\n        }\n      }\n    }\n    return target;\n  }, [explCamera, irisLeftDirPos, irisLeftLookAt, irisRightDirPos, irisRightLookAt, scene, target]); //\n  // update()\n  //\n  // Updating the camera `current` position and rotation, following `target`\n  //\n\n  const [current] = useState(() => new THREE.Object3D());\n  const update = useCallback(function (delta, target) {\n    if (explCamera) {\n      var _target;\n      (_target = target) !== null && _target !== void 0 ? _target : target = computeTarget();\n      if (smoothTime > 0) {\n        // damping current\n        const eps = 1e-9;\n        easing.damp3(current.position, target.position, smoothTime, delta, undefined, undefined, eps);\n        easing.dampE(current.rotation, target.rotation, smoothTime, delta, undefined, undefined, eps);\n      } else {\n        // instant\n        current.position.copy(target.position);\n        current.rotation.copy(target.rotation);\n      }\n      explCamera.position.copy(current.position);\n      explCamera.rotation.copy(current.rotation);\n    }\n  }, [explCamera, computeTarget, smoothTime, current.position, current.rotation]); //\n  // detect()\n  //\n\n  const [faces, setFaces] = useState();\n  const faceLandmarker = useFaceLandmarker();\n  const detect = useCallback((video, time) => {\n    const faces = faceLandmarker == null ? void 0 : faceLandmarker.detectForVideo(video, time);\n    setFaces(faces);\n  }, [faceLandmarker]);\n  useFrame((_, delta) => {\n    if (!manualUpdate) {\n      update(delta);\n    }\n  }); // Ref API\n\n  const api = useMemo(() => Object.assign(Object.create(THREE.EventDispatcher.prototype), {\n    detect,\n    computeTarget,\n    update,\n    facemeshApiRef,\n    webcamApiRef,\n    // shorthands\n    play: () => {\n      var _webcamApiRef$current, _webcamApiRef$current2;\n      (_webcamApiRef$current = webcamApiRef.current) == null ? void 0 : (_webcamApiRef$current2 = _webcamApiRef$current.videoTextureApiRef.current) == null ? void 0 : _webcamApiRef$current2.texture.source.data.play();\n    },\n    pause: () => {\n      var _webcamApiRef$current3, _webcamApiRef$current4;\n      (_webcamApiRef$current3 = webcamApiRef.current) == null ? void 0 : (_webcamApiRef$current4 = _webcamApiRef$current3.videoTextureApiRef.current) == null ? void 0 : _webcamApiRef$current4.texture.source.data.pause();\n    }\n  }), [detect, computeTarget, update]);\n  useImperativeHandle(fref, () => api, [api]); //\n  // events callbacks\n  //\n\n  useEffect(() => {\n    const onVideoFrameCb = e => {\n      if (!manualDetect) detect(e.texture.source.data, e.time);\n      if (onVideoFrame) onVideoFrame(e);\n    };\n    api.addEventListener('videoFrame', onVideoFrameCb);\n    return () => {\n      api.removeEventListener('videoFrame', onVideoFrameCb);\n    };\n  }, [api, detect, faceLandmarker, manualDetect, onVideoFrame]); // `controls` global state\n\n  useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls: api\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, api, get, set]);\n  const points = faces == null ? void 0 : faces.faceLandmarks[0];\n  const facialTransformationMatrix = faces == null ? void 0 : (_faces$facialTransfor = faces.facialTransformationMatrixes) == null ? void 0 : _faces$facialTransfor[0];\n  const faceBlendshapes = faces == null ? void 0 : (_faces$faceBlendshape = faces.faceBlendshapes) == null ? void 0 : _faces$faceBlendshape[0];\n  return /*#__PURE__*/React.createElement(FaceControlsContext.Provider, {\n    value: api\n  }, webcam && /*#__PURE__*/React.createElement(Suspense, {\n    fallback: null\n  }, /*#__PURE__*/React.createElement(Webcam, {\n    ref: webcamApiRef,\n    autostart: autostart,\n    videoTextureSrc: webcamVideoTextureSrc\n  })), /*#__PURE__*/React.createElement(Facemesh, _extends({\n    ref: facemeshApiRef\n  }, facemesh, {\n    points: points,\n    depth: depth,\n    facialTransformationMatrix: facialTransformationMatrix,\n    faceBlendshapes: faceBlendshapes,\n    eyes: eyes,\n    eyesAsOrigin: eyesAsOrigin,\n    offset: offset,\n    offsetScalar: offsetScalar,\n    debug: debug,\n    \"rotation-z\": Math.PI,\n    visible: debug\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    side: THREE.DoubleSide\n  })));\n});\nconst useFaceControls = () => useContext(FaceControlsContext); //\n// Webcam\n//\n\nconst Webcam = /*#__PURE__*/forwardRef((_ref2, fref) => {\n  let {\n    videoTextureSrc,\n    autostart = true\n  } = _ref2;\n  const videoTextureApiRef = useRef(null);\n  const faceControls = useFaceControls();\n  const stream = suspend(async () => {\n    return !videoTextureSrc ? await navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: {\n        facingMode: 'user'\n      }\n    }) : Promise.resolve(null);\n  }, [videoTextureSrc]);\n  useEffect(() => {\n    faceControls.dispatchEvent({\n      type: 'stream',\n      stream\n    });\n    return () => {\n      stream == null ? void 0 : stream.getTracks().forEach(track => track.stop());\n      clear([videoTextureSrc]);\n    };\n  }, [stream, faceControls, videoTextureSrc]); // ref-api\n\n  const api = useMemo(() => ({\n    videoTextureApiRef\n  }), []);\n  useImperativeHandle(fref, () => api, [api]);\n  return /*#__PURE__*/React.createElement(Suspense, {\n    fallback: null\n  }, /*#__PURE__*/React.createElement(VideoTexture, {\n    ref: videoTextureApiRef,\n    src: videoTextureSrc || stream,\n    start: autostart\n  }));\n}); //\n// VideoTexture\n//\n\nconst VideoTexture = /*#__PURE__*/forwardRef((_ref3, fref) => {\n  let {\n    src,\n    start\n  } = _ref3;\n  const texture = useVideoTexture(src, {\n    start\n  });\n  const video = texture.source.data;\n  const faceControls = useFaceControls();\n  const onVideoFrame = useCallback(time => {\n    faceControls.dispatchEvent({\n      type: 'videoFrame',\n      texture,\n      time\n    });\n  }, [texture, faceControls]);\n  useVideoFrame(video, onVideoFrame); // ref-api\n\n  const api = useMemo(() => ({\n    texture\n  }), [texture]);\n  useImperativeHandle(fref, () => api, [api]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null);\n});\nconst useVideoFrame = (video, f) => {\n  // https://web.dev/requestvideoframecallback-rvfc/\n  // https://www.remotion.dev/docs/video-manipulation\n  useEffect(() => {\n    if (!video || !video.requestVideoFrameCallback) return;\n    let handle;\n    function callback() {\n      f(...arguments);\n      handle = video.requestVideoFrameCallback(callback);\n    }\n    video.requestVideoFrameCallback(callback);\n    return () => video.cancelVideoFrameCallback(handle);\n  }, [video, f]);\n};\nexport { FaceControls, useFaceControls };","map":{"version":3,"names":["_extends","THREE","React","forwardRef","useRef","useState","useCallback","useMemo","useImperativeHandle","useEffect","Suspense","useContext","createContext","useThree","useFrame","easing","suspend","clear","useVideoTexture","Facemesh","useFaceLandmarker","mean","v1","v2","clone","add","multiplyScalar","localToLocal","objSrc","v","objDst","v_world","localToWorld","worldToLocal","FaceControlsContext","FaceControls","_ref","fref","camera","autostart","webcam","webcamVideoTextureSrc","manualUpdate","manualDetect","onVideoFrame","smoothTime","offset","offsetScalar","eyes","eyesAsOrigin","depth","debug","facemesh","makeDefault","_faces$facialTransfor","_faces$faceBlendshape","scene","state","defaultCamera","set","get","explCamera","webcamApiRef","facemeshApiRef","target","Object3D","irisRightDirPos","Vector3","irisLeftDirPos","irisRightLookAt","irisLeftLookAt","computeTarget","parent","facemeshApi","current","outerRef","eyeRightRef","eyeLeftRef","irisDirRef","irisRightDirRef","irisLeftDirRef","copy","position","lookAt","update","delta","_target","eps","damp3","undefined","dampE","rotation","faces","setFaces","faceLandmarker","detect","video","time","detectForVideo","_","api","Object","assign","create","EventDispatcher","prototype","play","_webcamApiRef$current","_webcamApiRef$current2","videoTextureApiRef","texture","source","data","pause","_webcamApiRef$current3","_webcamApiRef$current4","onVideoFrameCb","e","addEventListener","removeEventListener","old","controls","points","faceLandmarks","facialTransformationMatrix","facialTransformationMatrixes","faceBlendshapes","createElement","Provider","value","fallback","Webcam","ref","videoTextureSrc","Math","PI","visible","side","DoubleSide","useFaceControls","_ref2","faceControls","stream","navigator","mediaDevices","getUserMedia","audio","facingMode","Promise","resolve","dispatchEvent","type","getTracks","forEach","track","stop","VideoTexture","src","start","_ref3","useVideoFrame","Fragment","f","requestVideoFrameCallback","handle","callback","arguments","cancelVideoFrameCallback"],"sources":["/Users/lipeichen/Desktop/CRA/laptop-3-fiber/node_modules/@react-three/drei/core/FaceControls.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { forwardRef, useRef, useState, useCallback, useMemo, useImperativeHandle, useEffect, Suspense, useContext, createContext } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { easing } from 'maath';\nimport { suspend, clear } from 'suspend-react';\nimport { useVideoTexture } from './useVideoTexture.js';\nimport { Facemesh } from './Facemesh.js';\nimport { useFaceLandmarker } from './FaceLandmarker.js';\n\n// useVideoTexture 1st arg `src` type\nfunction mean(v1, v2) {\n  return v1.clone().add(v2).multiplyScalar(0.5);\n}\n\nfunction localToLocal(objSrc, v, objDst) {\n  // see: https://discourse.threejs.org/t/object3d-localtolocal/51564\n  const v_world = objSrc.localToWorld(v);\n  return objDst.worldToLocal(v_world);\n} //\n//\n//\n\n\nconst FaceControlsContext = /*#__PURE__*/createContext({});\nconst FaceControls = /*#__PURE__*/forwardRef(({\n  camera,\n  autostart = true,\n  webcam = true,\n  webcamVideoTextureSrc,\n  manualUpdate = false,\n  manualDetect = false,\n  onVideoFrame,\n  smoothTime = 0.25,\n  offset = true,\n  offsetScalar = 80,\n  eyes = false,\n  eyesAsOrigin = true,\n  depth = 0.15,\n  debug = false,\n  facemesh,\n  makeDefault\n}, fref) => {\n  var _faces$facialTransfor, _faces$faceBlendshape;\n\n  const scene = useThree(state => state.scene);\n  const defaultCamera = useThree(state => state.camera);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const explCamera = camera || defaultCamera;\n  const webcamApiRef = useRef(null);\n  const facemeshApiRef = useRef(null); //\n  // computeTarget()\n  //\n  // Compute `target` position and rotation for the camera (according to <Facemesh>)\n  //\n  //  1. ðŸ‘€ either following the 2 eyes\n  //  2. ðŸ‘¤ or just the head mesh\n  //\n\n  const [target] = useState(() => new THREE.Object3D());\n  const [irisRightDirPos] = useState(() => new THREE.Vector3());\n  const [irisLeftDirPos] = useState(() => new THREE.Vector3());\n  const [irisRightLookAt] = useState(() => new THREE.Vector3());\n  const [irisLeftLookAt] = useState(() => new THREE.Vector3());\n  const computeTarget = useCallback(() => {\n    // same parent as the camera\n    target.parent = explCamera.parent;\n    const facemeshApi = facemeshApiRef.current;\n\n    if (facemeshApi) {\n      const {\n        outerRef,\n        eyeRightRef,\n        eyeLeftRef\n      } = facemeshApi;\n\n      if (eyeRightRef.current && eyeLeftRef.current) {\n        // 1. ðŸ‘€\n        const {\n          irisDirRef: irisRightDirRef\n        } = eyeRightRef.current;\n        const {\n          irisDirRef: irisLeftDirRef\n        } = eyeLeftRef.current;\n\n        if (irisRightDirRef.current && irisLeftDirRef.current && outerRef.current) {\n          //\n          // position: mean of irisRightDirPos,irisLeftDirPos\n          //\n          irisRightDirPos.copy(localToLocal(irisRightDirRef.current, new THREE.Vector3(0, 0, 0), outerRef.current));\n          irisLeftDirPos.copy(localToLocal(irisLeftDirRef.current, new THREE.Vector3(0, 0, 0), outerRef.current));\n          target.position.copy(localToLocal(outerRef.current, mean(irisRightDirPos, irisLeftDirPos), explCamera.parent || scene)); //\n          // lookAt: mean of irisRightLookAt,irisLeftLookAt\n          //\n\n          irisRightLookAt.copy(localToLocal(irisRightDirRef.current, new THREE.Vector3(0, 0, 1), outerRef.current));\n          irisLeftLookAt.copy(localToLocal(irisLeftDirRef.current, new THREE.Vector3(0, 0, 1), outerRef.current));\n          target.lookAt(outerRef.current.localToWorld(mean(irisRightLookAt, irisLeftLookAt)));\n        }\n      } else {\n        // 2. ðŸ‘¤\n        if (outerRef.current) {\n          target.position.copy(localToLocal(outerRef.current, new THREE.Vector3(0, 0, 0), explCamera.parent || scene));\n          target.lookAt(outerRef.current.localToWorld(new THREE.Vector3(0, 0, 1)));\n        }\n      }\n    }\n\n    return target;\n  }, [explCamera, irisLeftDirPos, irisLeftLookAt, irisRightDirPos, irisRightLookAt, scene, target]); //\n  // update()\n  //\n  // Updating the camera `current` position and rotation, following `target`\n  //\n\n  const [current] = useState(() => new THREE.Object3D());\n  const update = useCallback(function (delta, target) {\n    if (explCamera) {\n      var _target;\n\n      (_target = target) !== null && _target !== void 0 ? _target : target = computeTarget();\n\n      if (smoothTime > 0) {\n        // damping current\n        const eps = 1e-9;\n        easing.damp3(current.position, target.position, smoothTime, delta, undefined, undefined, eps);\n        easing.dampE(current.rotation, target.rotation, smoothTime, delta, undefined, undefined, eps);\n      } else {\n        // instant\n        current.position.copy(target.position);\n        current.rotation.copy(target.rotation);\n      }\n\n      explCamera.position.copy(current.position);\n      explCamera.rotation.copy(current.rotation);\n    }\n  }, [explCamera, computeTarget, smoothTime, current.position, current.rotation]); //\n  // detect()\n  //\n\n  const [faces, setFaces] = useState();\n  const faceLandmarker = useFaceLandmarker();\n  const detect = useCallback((video, time) => {\n    const faces = faceLandmarker == null ? void 0 : faceLandmarker.detectForVideo(video, time);\n    setFaces(faces);\n  }, [faceLandmarker]);\n  useFrame((_, delta) => {\n    if (!manualUpdate) {\n      update(delta);\n    }\n  }); // Ref API\n\n  const api = useMemo(() => Object.assign(Object.create(THREE.EventDispatcher.prototype), {\n    detect,\n    computeTarget,\n    update,\n    facemeshApiRef,\n    webcamApiRef,\n    // shorthands\n    play: () => {\n      var _webcamApiRef$current, _webcamApiRef$current2;\n\n      (_webcamApiRef$current = webcamApiRef.current) == null ? void 0 : (_webcamApiRef$current2 = _webcamApiRef$current.videoTextureApiRef.current) == null ? void 0 : _webcamApiRef$current2.texture.source.data.play();\n    },\n    pause: () => {\n      var _webcamApiRef$current3, _webcamApiRef$current4;\n\n      (_webcamApiRef$current3 = webcamApiRef.current) == null ? void 0 : (_webcamApiRef$current4 = _webcamApiRef$current3.videoTextureApiRef.current) == null ? void 0 : _webcamApiRef$current4.texture.source.data.pause();\n    }\n  }), [detect, computeTarget, update]);\n  useImperativeHandle(fref, () => api, [api]); //\n  // events callbacks\n  //\n\n  useEffect(() => {\n    const onVideoFrameCb = e => {\n      if (!manualDetect) detect(e.texture.source.data, e.time);\n      if (onVideoFrame) onVideoFrame(e);\n    };\n\n    api.addEventListener('videoFrame', onVideoFrameCb);\n    return () => {\n      api.removeEventListener('videoFrame', onVideoFrameCb);\n    };\n  }, [api, detect, faceLandmarker, manualDetect, onVideoFrame]); // `controls` global state\n\n  useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls: api\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, api, get, set]);\n  const points = faces == null ? void 0 : faces.faceLandmarks[0];\n  const facialTransformationMatrix = faces == null ? void 0 : (_faces$facialTransfor = faces.facialTransformationMatrixes) == null ? void 0 : _faces$facialTransfor[0];\n  const faceBlendshapes = faces == null ? void 0 : (_faces$faceBlendshape = faces.faceBlendshapes) == null ? void 0 : _faces$faceBlendshape[0];\n  return /*#__PURE__*/React.createElement(FaceControlsContext.Provider, {\n    value: api\n  }, webcam && /*#__PURE__*/React.createElement(Suspense, {\n    fallback: null\n  }, /*#__PURE__*/React.createElement(Webcam, {\n    ref: webcamApiRef,\n    autostart: autostart,\n    videoTextureSrc: webcamVideoTextureSrc\n  })), /*#__PURE__*/React.createElement(Facemesh, _extends({\n    ref: facemeshApiRef\n  }, facemesh, {\n    points: points,\n    depth: depth,\n    facialTransformationMatrix: facialTransformationMatrix,\n    faceBlendshapes: faceBlendshapes,\n    eyes: eyes,\n    eyesAsOrigin: eyesAsOrigin,\n    offset: offset,\n    offsetScalar: offsetScalar,\n    debug: debug,\n    \"rotation-z\": Math.PI,\n    visible: debug\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    side: THREE.DoubleSide\n  })));\n});\nconst useFaceControls = () => useContext(FaceControlsContext); //\n// Webcam\n//\n\nconst Webcam = /*#__PURE__*/forwardRef(({\n  videoTextureSrc,\n  autostart = true\n}, fref) => {\n  const videoTextureApiRef = useRef(null);\n  const faceControls = useFaceControls();\n  const stream = suspend(async () => {\n    return !videoTextureSrc ? await navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: {\n        facingMode: 'user'\n      }\n    }) : Promise.resolve(null);\n  }, [videoTextureSrc]);\n  useEffect(() => {\n    faceControls.dispatchEvent({\n      type: 'stream',\n      stream\n    });\n    return () => {\n      stream == null ? void 0 : stream.getTracks().forEach(track => track.stop());\n      clear([videoTextureSrc]);\n    };\n  }, [stream, faceControls, videoTextureSrc]); // ref-api\n\n  const api = useMemo(() => ({\n    videoTextureApiRef\n  }), []);\n  useImperativeHandle(fref, () => api, [api]);\n  return /*#__PURE__*/React.createElement(Suspense, {\n    fallback: null\n  }, /*#__PURE__*/React.createElement(VideoTexture, {\n    ref: videoTextureApiRef,\n    src: videoTextureSrc || stream,\n    start: autostart\n  }));\n}); //\n// VideoTexture\n//\n\nconst VideoTexture = /*#__PURE__*/forwardRef(({\n  src,\n  start\n}, fref) => {\n  const texture = useVideoTexture(src, {\n    start\n  });\n  const video = texture.source.data;\n  const faceControls = useFaceControls();\n  const onVideoFrame = useCallback(time => {\n    faceControls.dispatchEvent({\n      type: 'videoFrame',\n      texture,\n      time\n    });\n  }, [texture, faceControls]);\n  useVideoFrame(video, onVideoFrame); // ref-api\n\n  const api = useMemo(() => ({\n    texture\n  }), [texture]);\n  useImperativeHandle(fref, () => api, [api]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null);\n});\n\nconst useVideoFrame = (video, f) => {\n  // https://web.dev/requestvideoframecallback-rvfc/\n  // https://www.remotion.dev/docs/video-manipulation\n  useEffect(() => {\n    if (!video || !video.requestVideoFrameCallback) return;\n    let handle;\n\n    function callback(...args) {\n      f(...args);\n      handle = video.requestVideoFrameCallback(callback);\n    }\n\n    video.requestVideoFrameCallback(callback);\n    return () => video.cancelVideoFrameCallback(handle);\n  }, [video, f]);\n};\n\nexport { FaceControls, useFaceControls };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}